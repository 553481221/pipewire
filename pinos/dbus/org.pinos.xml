<!DOCTYPE node PUBLIC
    "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"
    "http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd" >
<node xmlns:doc="http://www.freedesktop.org/dbus/1.0/doc.dtd">
  <!--
      org.pinos.Daemon1:
      @short_description: Main interface for the pinos daemon

      Interface to get properties from the pinos daemon and to
      establish a client connection.
  -->
  <interface name='org.pinos.Daemon1'>
    <!-- UserName: Name of the user that started the daemon -->
    <property name='UserName' type='s' access='read' />
    <!-- HostName: Name of the machine the daemon is running on -->
    <property name='HostName' type='s' access='read' />
    <!-- Version: Version of the daemon -->
    <property name='Version' type='s' access='read' />
    <!-- Name: Name of the daemon -->
    <property name='Name' type='s' access='read' />
    <!-- Cookie: A random cookie for identifying this instance of Pinos -->
    <property name='Cookie' type='u' access='read' />
    <!-- Properties: Extra properties of the daemon -->
    <property name='Properties' type='a{sv}' access='read' />
    <!-- ConnectClient:
         @properties: properties of the client
         @client: a new client object

         Register a client to the pinos daemon. A new client object
         will be generated that should be used to perform any other
         action on the server.
    -->
    <method name='ConnectClient'>
      <arg type='a{sv}' name='properties' direction='in'/>
      <arg type='o' name='client' direction='out'/>
    </method>
  </interface>

  <!--
      org.pinos.Client1:
      @short_description: Main client interface

      Interface obtained after connecting a client and allows for
      obtaining an channel object from a source/sink.
  -->
  <interface name='org.pinos.Client1'>
    <!-- Name: Name of the client -->
    <property name='Name' type='s' access='read' />
    <!-- Name: Properties of the client -->
    <property name='Properties' type='a{sv}' access='read' />
    <!-- Disconnect:

         Disconnect the client from the server.
    -->
    <method name='Disconnect'/>
    <!-- CreateSourceChannel:
         @source: the Source1 object path or / for default
         @possible_formats: the possible formats that can be accepted
         @properties: extra properties
         @channel: the Channel object path

         Create a new channel to capture from @source with given @possible_formats
    -->
    <method name='CreateSourceChannel'>
      <arg type='s' name='source' direction='in'/>
      <arg type='s' name='possible_formats' direction='in'/>
      <arg type='a{sv}' name='properties' direction='in'/>
      <arg type='o' name='channel' direction='out'/>
    </method>

    <!-- CreateSinkChannel:
         @sink: the Sink1 object path or / for default
         @possible_formats: the possible formats that can be provided
         @properties: extra properties
         @channel: the Channel object path

         Create a new channel to playback to @sink with given @possible_formats
    -->
    <method name='CreateSinkChannel'>
      <arg type='s' name='sink' direction='in'/>
      <arg type='s' name='possible_formats' direction='in'/>
      <arg type='a{sv}' name='properties' direction='in'/>
      <arg type='o' name='channel' direction='out'/>
    </method>
    <!-- CreateUploadChannel:
         @possible_formats: the formats that can be provided
         @properties: extra properties
         @channel: the Channel object path

         Create a new channel to upload a new stream
    -->
    <method name='CreateUploadChannel'>
      <arg type='s' name='possible_formats' direction='in'/>
      <arg type='a{sv}' name='properties' direction='in'/>
      <arg type='o' name='channel' direction='out'/>
    </method>

  </interface>

  <!--
      org.pinos.Source1:
      @short_description: Main source interface

      A source is an object that can provide media content.
  -->
  <interface name='org.pinos.Source1'>
    <!-- Name: the name of the source -->
    <property name='Name' type='s' access='read' />
    <!-- Properties: extra source properties -->
    <property name='Properties' type='a{sv}' access='read' />
    <!-- state: state of the source
          -1 = the source is in error
          0 = the source is suspended, this means the device is closed
          1 = the source is initializing
          2 = the source is idle, this means the device is opened but
              no channel is consuming the data
          3 = the source is running
    -->
    <property name='State' type='u' access='read' />
    <!-- PossibleFormats:

         The all possible formats of this source.
    -->
    <property name='PossibleFormats' type='s' access='read' />
  </interface>

  <!--
      org.pinos.Sink1:
      @short_description: Main sink interface

      A sink is an object that can consume media content.
  -->
  <interface name='org.pinos.Sink1'>
    <!-- Name: the name of the sink -->
    <property name='Name' type='s' access='read' />
    <!-- Properties: extra sink properties -->
    <property name='Properties' type='a{sv}' access='read' />
    <!-- state: state of the sink
          -1 = the sink is in error
          0 = the sink is suspended, this means the device is closed
          1 = the sink is initializing
          2 = the sink is idle, this means the device is opened but
              no channel is providing any data
          3 = the sink is running
    -->
    <property name='State' type='u' access='read' />
    <!-- PossibleFormats:

         The all possible formats of this sink.
    -->
    <property name='PossibleFormats' type='s' access='read' />
  </interface>

  <!--
      org.pinos.Channel:
      @short_description: Interface for input/output channel

      This interface is used to control the input/output of a
      source/sink and start/stop the media transport.
  -->
  <interface name='org.pinos.Channel1'>
    <!-- Client: the owner client of this channel -->
    <property name='Client' type='o' access='read' />
    <!-- Owner: the owner source/sink of this channel -->
    <property name='Owner' type='o' access='read' />
    <!-- type: type of the channel
          0 = input channel
          1 = output channel
    -->
    <property name='Type' type='u' access='read' />
    <!-- PossibleFormats:
         all possible formats of the channel. This is filtered
         against the accepted_formats when creating the channel.
         -->
    <property name='PossibleFormats' type='s' access='read' />

    <!-- Properties: extra channel properties -->
    <property name='Properties' type='a{sv}' access='read' />

    <!-- state: state of the channel
          -1 = the channel is in error
          0 = the channel is idle
          1 = the channel is starting
          2 = the channel is streaming
    -->
    <property name='State' type='u' access='read' />
    <!-- Format: the current streaming format -->
    <property name='Format' type='s' access='read' />

    <!-- Start:
         @requested_format: requested formats
         @fd: output file descriptor
         @format: channel format
         @properties: channel properties

         Start the datatransfer on the channel with @requested_format.

         The result is a file descriptor that can be used to send/receive
         metadata and media. @format contains the final media format and
         @properties the extra properties that describe the media format.
    -->
    <method name='Start'>
      <arg type='s' name='requested_format' direction='in'/>
      <arg type='h' name='fd' direction='out'/>
      <arg type='s' name='format' direction='out'/>
      <arg type='a{sv}' name='properties' direction='out'/>
    </method>
    <!-- Stop:

         Stop data transport on the channel
    -->
    <method name='Stop'/>
    <!-- Remove:

         Remove the channel
    -->
    <method name='Remove'/>

    <!-- This is a possible push based API. It would require a dbus call
         for each media packet, which is probably not a good idea right now.
         We would probably also want something more lightweight for sending
         the properties with each fd.

    <method name='Start'>
      <arg type='a{sv}' name='props' direction='in'/>
      <arg type='a{sv}' name='props' direction='out'/>
    </method>
    <method name='Stop'>
    </method>
    <signal name='NewData'>
      <arg type='h' name='data' direction='out'/>
      <arg type='a{sv}' name='props' direction='out'/>
    </signal>
    <method name='FreeData'>
      <arg type='h' name='data' direction='in'/>
    </method>
    -->
  </interface>
</node>
